import angr
import claripy
import cle
import archinfo
import simuvex
import sys
import itertools
import re

var_counter = itertools.count()

def if_comefrom_input(data):
    pattern = re.compile(r'taint')
    match = pattern.search(str(data.args[0]))
    if match:
        return True
    else:
        return False

def get_path(state):
    stashes = pg.stashes
    conb = []
    for b in state.se.constraints:
        conb.append(b._hash)
    hash_conb = hash(str(conb))
    for _, pa in stashes.iteritems():
        for paa in pa:
            cona = []
            for a in paa.state.se.constraints:
                cona.append(a._hash)
            hash_cona = hash(str(cona))
            if hash_cona == hash_conb:
                return paa
def get_trace(path_for_trace):
    ta =path_for_trace.trace.__reversed__()
    trace = []
    for t in ta:
        trace.append(t)
    return trace[::-1]

def call_pre_analysis(state):
    fun_name = getattr(state.inspect,'simprocedure_name')
    fun_address = getattr(state.inspect, 'simprocedure_addr')
    
    try:
        func_object = proj._sim_procedures[fun_address].procedure(fun_address,proj.arch)
    except Exception,e:
        return 
    paa = get_path(state)
    paa_trace = get_trace(paa)
    state_ip = state.se.any_int(state.ip) 
    if fun_name == 'malloc':
        arg_reg = func_object.cc.arg(state,0)
        if if_comefrom_input(arg_reg):
            f = open('detect_result_fully_constrained.txt','a')
            f.write('fully constrainted input:'+str([hex(i) for i in paa.addr_trace] + [hex(state.ip)])+'\n')
            f.close()
            print paa_trace
    elif fun_name == 'memcpy':
        arg_reg = func_object.cc.arg(state,2)
        #print 'memcpy_limit:',arg_reg
        if if_comefrom_input(arg_reg):
            f = open('detect_result_fully_constrained.txt','a')
            f.write('fully constrainted input:'+str([hex(i) for i in paa.addr_trace] + [hex(state_ip)])+'\n')
            f.close()
            print paa_trace
    elif fun_name == 'memmove':
        arg_reg = func_object.cc.arg(state,2)
        if if_comefrom_input(arg_reg):
            f = open('detect_result_fully_constrained.txt','a')
            f.write('fully constrainted input:'+str([hex(i) for i in paa.addr_trace] + [hex(paa._run.addr)])+'\n')
            f.close()
            print paa_trace
    elif fun_name == 'realloc':
        arg_reg = func_object.cc.arg(state,1)
        if if_comefrom_input(arg_reg):
            f = open('detect_result_fully_constrained.txt','a')
            f.write('fully constrainted input:'+str([hex(i) for i in paa.addr_trace] + [hex(paa._run.addr)])+'\n')
            f.close()
            print paa_trace
    elif fun_name == 'strncpy':
        arg_reg = func_object.cc.arg(state,2)
        if if_comefrom_input(arg_reg):
            f = open('detect_result_fully_constrained.txt','a')
            f.write('fully constrainted input:'+str([hex(i) for i in paa.addr_trace] + [hex(paa._run.addr)])+'\n')
            f.close()
            print paa_trace 
    
def call_post_analysis(state):
    fun_name = getattr(state.inspect,'simprocedure_name')
    fun_address = getattr(state.inspect, 'simprocedure_addr')
    try:
        func_object = proj._sim_procedures[fun_address].procedure(fun_address,proj.arch)
    except Exception,e:
        return 
    if fun_name == 'fread':
        arg0_reg = func_object.cc.arg(state,0)
        arg1_reg = func_object.cc.arg(state,1)
        arg2_reg = func_object.cc.arg(state,2)
        size = state.se.max_int(arg1_reg) * state.se.max_int(arg2_reg)
        for i in range(size):
            state.memory.make_symbolic('taint', arg0_reg+i, size)
    elif fun_name == 'read':
        arg0_reg = func_object.cc.arg(state,0)
        arg1_reg = func_object.cc.arg(state,1)
        arg2_reg = func_object.cc.arg(state,2)
        size = state.se.max_int(arg2_reg)
        for i in range(size):
            state.memory.make_symbolic('taint', arg1_reg+i, size)
                
    elif fun_name == 'recv':
        arg0_reg = func_object.cc.arg(state,0)
        arg1_reg = func_object.cc.arg(state,1)
        arg2_reg = func_object.cc.arg(state,2)
        size = state.se.max_int(arg2_reg)
        for i in range(size):
            state.memory.make_symbolic('taint', arg1_reg+i, size)
    elif fun_name == 'recvfrom':
        arg0_reg = func_object.cc.arg(state,0)
        arg1_reg = func_object.cc.arg(state,1)
        arg2_reg = func_object.cc.arg(state,2)
        size = state.se.max_int(arg2_reg)
        for i in range(size):
            state.memory.make_symbolic('taint', arg1_reg+i, size)
 
def exit_pre_analysis(state):
    exit_sim_target = getattr(state.inspect,'exit_target')
    paa = get_path(state)
    paa_trace = get_trace(paa)
    if if_comefrom_input(exit_sim_target):
        f = open('detect_result_fully_constrained.txt','a')
        if list(state.log.actions):
            block_addr = list(state.log.actions)[0].bbl_addr
        else:
            block_addr = state.se.any_int(state.ip)
        f.write('fully constrainted input:'+str([hex(i) for i in paa.addr_trace] + [hex(block_addr)])+'\n')
        f.close()
        print paa_trace

if __name__=='__main__':
    global proj, proj_main_bin
    
    proj = angr.Project(sys.argv[1])
    func_addr = int(sys.argv[2],16)
    proj_main_bin = proj.loader.main_bin
    f = open('detect_result_fully_constrained.txt','w')
    f.close()
    entr_state = proj.factory.blank_state(addr=func_addr,concrete_fs=True,remove_options=set(['COW_STATES']))
    entr_state.inspect.b('simprocedure', when=simuvex.BP_BEFORE, action=call_pre_analysis)
    entr_state.inspect.b('simprocedure', when=simuvex.BP_AFTER, action=call_post_analysis)
    entr_state.inspect.b('exit', when=simuvex.BP_BEFORE, action=exit_pre_analysis)
    p = proj.factory.path(state=entr_state)
    pg = proj.factory.path_group(p)
    pg.explore()
   
