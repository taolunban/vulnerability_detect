import angr
import claripy
import cle
import archinfo
import simuvex
import sys
import itertools
import re
import son_father_process

var_counter = itertools.count()

def if_comefrom_input(data):
    pattern = re.compile(r'taint')
    match = pattern.search(str(data.args[0]))
    if match:
        print 'fully_constrainted_input danger!!!'
        return True
    else:
        return False

# ************ added by pjq ************
def get_trace(state):
    trace = []
    son_father = son_father_process.get_son_father()
    father = str(state)
    while father:
        trace.insert(0, son_father[father][0])
        father = son_father[father][1]
    return trace

def call_pre_analysis(state):
    fun_name = getattr(state.inspect,'simprocedure_name')
    fun_address = getattr(state.inspect, 'simprocedure_addr')
    
    try:
        func_object = proj._sim_procedures[fun_address].procedure(fun_address,proj.arch)
    except Exception,e:
        return 
    block_state = son_father_process.get_state()
    paa_trace = get_trace(block_state)
    
    if fun_name == 'malloc':
        arg_reg = func_object.cc.arg(state,0)
        if if_comefrom_input(arg_reg):
            print paa_trace
    elif fun_name == 'memcpy':
        arg_reg = func_object.cc.arg(state,2)
        #print 'memcpy_limit:',arg_reg
        if if_comefrom_input(arg_reg):
            print paa_trace
    elif fun_name == 'memmove':
        arg_reg = func_object.cc.arg(state,2)
        if if_comefrom_input(arg_reg):
            print paa_trace
    elif fun_name == 'realloc':
        arg_reg = func_object.cc.arg(state,1)
        if if_comefrom_input(arg_reg):
            print paa_trace
    elif fun_name == 'strncpy':
        arg_reg = func_object.cc.arg(state,2)
        if if_comefrom_input(arg_reg):
            print paa_trace 
    
def call_post_analysis(state):
    fun_name = getattr(state.inspect,'simprocedure_name')
    fun_address = getattr(state.inspect, 'simprocedure_addr')
    try:
        func_object = proj._sim_procedures[fun_address].procedure(fun_address,proj.arch)
    except Exception,e:
        return 
    if fun_name == 'fread':
        arg0_reg = func_object.cc.arg(state,0)
        arg1_reg = func_object.cc.arg(state,1)
        arg2_reg = func_object.cc.arg(state,2)
        size = state.se.max_int(arg1_reg) * state.se.max_int(arg2_reg)
        for i in range(size):
            state.memory.make_symbolic('taint', arg0_reg+i, size)
    elif fun_name == 'read':
        arg0_reg = func_object.cc.arg(state,0)
        arg1_reg = func_object.cc.arg(state,1)
        arg2_reg = func_object.cc.arg(state,2)
        size = state.se.max_int(arg2_reg)
        for i in range(size):
            state.memory.make_symbolic('taint', arg1_reg+i, size)
    elif fun_name == 'recv':
        arg0_reg = func_object.cc.arg(state,0)
        arg1_reg = func_object.cc.arg(state,1)
        arg2_reg = func_object.cc.arg(state,2)
        size = state.se.max_int(arg2_reg)
        for i in range(size):
            state.memory.make_symbolic('taint', arg1_reg+i, size)
    elif fun_name == 'recvfrom':
        arg0_reg = func_object.cc.arg(state,0)
        arg1_reg = func_object.cc.arg(state,1)
        arg2_reg = func_object.cc.arg(state,2)
        size = state.se.max_int(arg2_reg)
        for i in range(size):
            state.memory.make_symbolic('taint', arg1_reg+i, size)
 
def exit_pre_analysis(state):
    exit_sim_target = getattr(state.inspect,'exit_target')
    block_state = son_father_process.get_state()
    paa_trace = get_trace(block_state)
    if if_comefrom_input(exit_sim_target):
        print paa_trace


def initialize(proj0, func_addr0, entr_state0):
    global proj, func_addr, proj_main_bin
    proj = proj0
    func_addr = func_addr0
    entr_state = entr_state0
    proj_main_bin = proj.loader.main_bin     
    entr_state.inspect.b('simprocedure', when=simuvex.BP_BEFORE, action=call_pre_analysis)
    entr_state.inspect.b('simprocedure', when=simuvex.BP_AFTER, action=call_post_analysis)
    entr_state.inspect.b('exit', when=simuvex.BP_BEFORE, action=exit_pre_analysis)
    return entr_state

if __name__=='__main__':
    proj = angr.Project(sys.argv[1])
    func_addr = int(sys.argv[2],16)
    entr_state = proj.factory.blank_state(addr=func_addr,concrete_fs=True,remove_options=set(['COW_STATES']))
    entr_state = initialize(proj, func_addr, entr_state)
    p = proj.factory.path(state=entr_state)
    pg = proj.factory.path_group(p)
    pg.explore()   
