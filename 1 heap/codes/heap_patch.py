import angr
import simuvex
import claripy
import copy
import sys
import heap_patch_core
import son_father_process


def get_path_uninit_var(path_uninit_var, addr, state, binary):
    if state is None:
        return path_uninit_var
    if not path_uninit_var.has_key(addr):
        item_list = [] 
        events = [i for i in state.log.events if i not in state.log.actions]
        event_stmt_idxs = []
        for e in events:
            if e.type == 'uninitialized':
                if e.sim_procedure:
                    item = {'sim_procedure':e.sim_procedure,
                            'variable':e.objects}
                    #print item
                    item_list.append(item)
                else:
                    if e.stmt_idx not in event_stmt_idxs:
                        if e.objects['addr'] != sp_addr:   #ret instruction:  ip=[sp]
                            proj = angr.Project(binary)
                            irsb = proj.factory.block(addr).vex
                            item = {'ins_addr':hex(e.ins_addr),
                                    'stmt':irsb.statements[e.stmt_idx].__str__(),
                                    'var_addr':hex(e.objects['addr'])}
                            gotaddr_flag = 0
                            for a in state.log.actions:
                                if a.stmt_idx==e.stmt_idx:
                                    if a.type=='tmp' and a.action=='read':
                                        item['related_addr'] = a.data.ast
                                        gotaddr_flag += 1
                                    if (a.type=='reg' and a.action=='read') or a.type=='mem':
                                        item['varname'] = a.data.ast
                                        gotaddr_flag += 1
                                    if gotaddr_flag == 2:
                                        break
                            #print item
                            item_list.append(item)
                        event_stmt_idxs.append(e.stmt_idx)
        #print 'item_list:',item_list 
        path_uninit_var[addr] = item_list                
    return path_uninit_var



def print_uninit_var(uninit_var_list):
    print '\nhere is print uninit_var_list:'
    for i in uninit_var_list:
        if i.has_key('sim_procedure'):
            print i['sim_procedure'],i['variable']
        elif i.has_key('related_addr'):
            print i['ins_addr'],i['stmt'],i['varname'],i['var_addr'],i['related_addr']
        else:
            print i['ins_addr'],i['stmt'],i['varname'],i['var_addr']
    print    

 
def run_original_function(trace):
    # for original function, user will input a trace that can trigger crash
    # trace: a list of executed block addr
    
    print '\n########  Run Original Function  ########\n'
    global old_uninit_var_list, old_constraints
    q = [init_state1]
    addr_state = []
    trace_id = 0
    trace_end = False
    while len(q) > 0:
        state = q.pop()
        if state.se.symbolic(state.ip):
            break
        last_state = state
        trace_id = trace_id + 1
        curr_ip = state.se.any_int(state.ip)
        #print '\nblock addr:',hex(curr_ip)
        p = proj1.factory.path(state)
        p.step()
        if not p.next_run:
            continue
        succ_states = p.next_run.successors
        for s in succ_states:
            if trace_id < len(trace):
                if s.se.any_int(s.ip) == trace[trace_id]:
                    q.append(s)
                    addr_state.append((curr_ip,s))
                    break
            else:
                addr_state.append((curr_ip,s))
                trace_end = True
                break
        if not succ_states:
            succ = p.next_run.unconstrained_successors
            if len(succ)>1:
                print "Warning: more than one unconstrained_successors"
            if succ:
                q.append(succ[0])
                addr_state.append((curr_ip,succ[0]))
            else:
                addr_state.append((curr_ip,None))
        if trace_end:
            break
    #print 'addr_state:'
    #for i in addr_state):
    #    print hex(i[0]),i[1]
    path_uninit_var = {}
    for i in addr_state:
        path_uninit_var = get_path_uninit_var(path_uninit_var,i[0],i[1],binary1)
    old_uninit_var_list = reduce(lambda x,y:x+y, [path_uninit_var[i[0]] for i in addr_state if i[1]])
    print_uninit_var(old_uninit_var_list)
    old_constraints = last_state.se.constraints
    print 'old constraints:'
    for i in old_constraints:
        print i

        
def get_args():
    global argument_registers, argument_stacks

    proj = proj1
    new_sp_addr = sp_addr - proj.arch.stack_change
    accessed_registers = set()
    accessed_registers.add(proj.arch.registers['bp'][0])
    accessed_registers.add(proj.arch.registers['sp'][0])
    argument_registers = {}
    argument_stacks = {}
    argument_register_size = {}
    argument_stack_size = {}
    
    q = [init_state1]
    block_exectimes = {}
    
    while len(q) > 0:
        state = q.pop()
        curr_ip = state.se.any_int(state.ip)
        # limit execution times of each block
        if block_exectimes.has_key(curr_ip):
            t = block_exectimes[curr_ip]
            if t > 9:
                continue
            else:
                block_exectimes[curr_ip] = t+1
        else:
            block_exectimes[curr_ip] = 1
    
        p = proj.factory.path(state) 
        p.step()
        if not p.next_run:
            continue

        succ_states = p.next_run.successors
        # there are two situations that need special treatment:
        #   a. fail to reach next block: the last block of func, call symbolic_addr ...
        #   b. there is no next block: exit(0) ...
        if not succ_states:
            succ_states = p.next_run.unconstrained_successors
        # calculate argument of function
        if succ_states:
            succ = succ_states[0]
            actions = list(succ.log.actions)
            for i in xrange(len(actions)):
                a = actions[i]
                if a.type == 'mem' and a.action == 'read':
                    try:
                        addr = succ.se.exactly_int(a.addr.ast, default=0)
                    except claripy.ClaripyError:
                        continue
                    stack_boundary = 0xc0 << (proj.arch.bits-8)
                    if addr >= new_sp_addr and addr < stack_boundary:
                        offset = addr - new_sp_addr
                        if offset not in argument_stacks:
                            argument_stacks[offset] = ('mem_%x' % addr, a.data.ast)
                            argument_stack_size[offset] = a.data.ast.length
                elif a.type == "reg":
                    offset = a.offset
                    if a.action == "read" and offset not in accessed_registers:
                        #reg_varname = 'reg_%x' % offset
                        #argument_registers[reg_varname] = a.data.ast 
                        reg_ast = a.data.ast
                        if not reg_ast.variables:
                            continue
                        reg_varname = list(reg_ast.variables)[0]
                        argument_registers[reg_varname] = reg_ast
                        
                        # calculate size of the read reg
                        j = i+1
                        while j<len(actions):
                            a1 = actions[j] 
                            try:
                                if a1.action=='write' and a1.type=='mem':
                                    tmp = a1.data.ast
                                    if tmp.variables and list(tmp.variables)[0] == reg_varname:
                                        argument_register_size[reg_varname] = tmp.length
                                        break
                            except:
                                pass
                            j = j+1
                        
                    elif a.action == "write":
                        accessed_registers.add(offset)   
        
        # add successors to the queue to analyze
        for succ in succ_states:
            if not succ.se.symbolic(succ.ip):
                #print 'succ.ip:',succ.ip
                q.insert(0, succ)

    Arch_Arg_Regs = simuvex.DefaultCC[proj.arch.name].ARG_REGS + simuvex.DefaultCC[proj.arch.name].FP_ARG_REGS 
    regs = {}
    for i in Arch_Arg_Regs:
        regs[proj.arch.registers[i][0]] = i
    argument_regname = []
    argument_print = []
    for i in argument_registers:
        j = int('0x'+i.split('_')[1],16)
        if regs.has_key(j):
            argument_regname.append(regs[j])
            argument_print.append([regs[j],i,argument_register_size[i]])
    #print '\nregister argument:',argument_regname
    print '\nregister argument:',argument_print
    print '\nstack argument:',[(i,argument_stacks[i][1],argument_stack_size[i]) for i in argument_stacks]
    print



def get_mem2addr(uninit_var_list):
    # analyze old_uninit_var_list (for origin binary)
    mem_addr = {}
    for uninit in uninit_var_list:
        if not uninit.has_key('simprocedure') and uninit.has_key('related_addr'):
            if uninit['related_addr'].symbolic:
                var = list(uninit['varname'].variables)[0]
                mem_addr[var] = (uninit['varname'],uninit['related_addr'])
    return mem_addr
       
def get_addr2mem(uninit_var_list):
     # analyze new_uninit_var_list (for patched binary)
    addr_mem = {}
    for uninit in uninit_var_list:
        if not uninit.has_key('simprocedure') and uninit.has_key('related_addr'):
            if uninit['related_addr'].symbolic:
                addr_mem[uninit['related_addr']] = uninit['var_addr'] 
    return addr_mem 

def recursive_delete_constraint(constraint, target_ast,typ):
    if constraint is None:
        return None
    op = constraint.op
    depth = constraint.depth
    comparator_operations = claripy.operations.expression_comparator_operations.union(claripy.operations.backend_comparator_operations)
    if depth >= 2:
        if op == 'And':
            new_con_list = []
            for arg in constraint.args:
                con = recursive_delete_constraint(arg,target_ast,typ)
                if con is None:
                    if typ == 'mem':
                        return None
                else:
                    new_con_list.append(con)
            if len(new_con_list)>=2:
                return claripy.ast.bool.Bool(op,tuple(new_con_list))
            elif len(new_con_list)==1:
                return new_con_list[0]
            else:
                return None
        elif op == 'Or':
            new_con_list = []
            for arg in constraint.args:
                con = recursive_delete_constraint(arg,target_ast,typ)
                if con is not None:
                    new_con_list.append(con)
            if len(new_con_list)>=2:
                return claripy.ast.bool.Bool(op,tuple(new_con_list))
            elif len(new_con_list)==1:
                return new_con_list[0]
            else:
                return None
        elif op == 'Not':
            new_con = recursive_delete_constraint(constraint.args[0],target_ast,typ)
            if new_con is None:
                return None
            return claripy.ast.bool.Bool(op,(new_con,))
        elif op in comparator_operations:
            for arg in constraint.args:
                if arg.symbolic:
                    variables = [i.args[0] for i in arg.recursive_leaf_asts if i.symbolic]
                    if target_ast.args[0] in variables:
                        return None
            return constraint
        else:  # other operations
            #print 'other operations:',constraint,op
            return constraint
    else:
        return constraint 

def check_pointer(ast, new_ast, mem_addr, state):
    #print 'check_pointer:',ast,new_ast
    pointer_info = {}
    for mem in mem_addr:
        addr_ast = mem_addr[mem][1]
        if addr_ast.length == ast.length:
            if addr_ast.op == 'BVS' and state.se.unique(ast-addr_ast):
                #print 'op is BVS:',addr_ast
                if new_ast.args[0] != ast.args[0]:
                    addr_ast = addr_ast.replace(ast,new_ast)
                pointer_info[mem] = (mem_addr[mem][0],addr_ast)
            elif addr_ast.op == '__add__' and state.se.unique(ast-addr_ast.args[0]):
                #print 'op is ADD:',addr_ast
                if new_ast.args[0] != ast.args[0]:
                    addr_ast = addr_ast.replace(ast,new_ast)
                    #print 'update addr_ast:',addr_ast
                pointer_info[mem] = (mem_addr[mem][0],addr_ast)
    return pointer_info    

def get_con_ast(con, mem_ast):
    for ast in con.recursive_leaf_asts:
        if ast.args[0] == mem_ast.args[0]:
            return ast
    return mem_ast
    
def cons_transfer(constraints, new_uninit_var_list):
    #print "######## Constraints Transfer ########"
    global pointer_list, changed_mem_name
    
    addr_mem = get_addr2mem(new_uninit_var_list)
    #print '\naddr_mem:'
    #for a in addr_mem:
    #    print a,addr_mem[a]
    all_cons = constraints
    ss = init_state2
    
    q = copy.deepcopy(pointer_list)
    while len(q)>0:
        pointer = q.pop()
        pointer_name = pointer[0]
        pointer_ast = pointer[1]
        pointer_info = pointer[2]  # dict {mem_name:(mem_ast,addr_ast)}
        #print '\n\npointer_name:',pointer_name
        #print 'pointer_ast:',pointer_ast
        #print 'pointer_info:'
        #for i in pointer_info:
        #    print i,pointer_info[i]
        new_cons = []
        new_pointer_dict = {}
        for con in all_cons:
            if con is None:
                continue
            new_con = con
            #print 'each con:',new_con
            variables = [i.args[0] for i in new_con.recursive_leaf_asts if i.symbolic]
            if pointer_name in variables:
                #print 'need to delete'
                new_con = recursive_delete_constraint(new_con,pointer_ast,'addr')
                if new_con is None:
                    continue
            new_pointer = []
            variables = [i.args[0] for i in new_con.recursive_leaf_asts if i.symbolic]
            for mem_name in variables:
                if mem_name in changed_mem_name:
                    continue
                if pointer_info.has_key(mem_name):
                    #print 'mem_name:',mem_name
                    mem_ast = pointer_info[mem_name][0]
                    addr_ast = pointer_info[mem_name][1]
                    new_mem_name = mem_name
                    new_mem_ast = mem_ast
                    for a in addr_mem:
                        if ss.se.unique(addr_ast-a):
                            new_mem_name = 'mem_%x' % ss.se.any_int(eval(addr_mem[a])+(addr_ast-a))
                            if new_mem_name != mem_name:
                                mem_ast = get_con_ast(new_con,mem_ast)
                                mem_length = mem_ast.length
                                uc_alloc_depth = mem_ast.uc_alloc_depth
                                new_mem_ast = ss.se.BVS(new_mem_name,mem_length,explicit_name=True,**{'uc_alloc_depth':uc_alloc_depth})
                                #print 'old_mem_ast:',mem_ast
                                #print 'new_mem_ast:',new_mem_ast
                                new_con = new_con.replace(mem_ast,new_mem_ast)
                            changed_mem_name.append(new_mem_name)
                            break
                    new_pointer_info = check_pointer(mem_ast,new_mem_ast,mem_addr,ss)
                    if new_pointer_info and not new_pointer_dict.has_key(new_mem_name):
                        new_pointer_dict[new_mem_name] = (new_mem_ast,new_pointer_info)
            
            if new_con is not None: 
                #print 'new_con:',new_con
                new_cons.append(new_con)    

        for m in new_pointer_dict:
            q.insert(0,(m,new_pointer_dict[m][0],new_pointer_dict[m][1]))
            if m not in [i[0] for i in pointer_list]:
                pointer_list.insert(0,(m,new_pointer_dict[m][0],new_pointer_dict[m][1]))
        all_cons = new_cons            
    
    print '**** New Cons ****'
    for c in all_cons:
        print c
    return all_cons
   
     
def get_trace(state):
    trace = []
    son_father = son_father_process.get_son_father()
    father = str(state)
    while father:
        trace.insert(0, son_father[father][0])
        father = son_father[father][1]
    return trace

def detect_with_new_cons(state):
    print '\n\n>>>>>>>>> Step, Add cons and Detect errors >>>>>>>>>'
    global path_uninit_var, block_cons

    state_ip = state.se.any_int(state.ip)
    print 'state_ip:',hex(state_ip),state
    son_father_process.set_state(state)
    p = proj2.factory.path(state)
    p.step()
    if p.next_run is None:
        print 'Something wrong happen! Fail to step!'
        return []
    succ_states = p.next_run.successors
    if not succ_states:
        succ_states = p.next_run.unconstrained_successors
    if succ_states:
        succ = succ_states[0]
    else:
        succ = None
    path_uninit_var = get_path_uninit_var(path_uninit_var, state_ip, succ, binary2)
    trace = get_trace(state)
    print 'trace:',[hex(i) for i in trace]
    uninit_var_list = reduce(lambda x,y: x+y, [path_uninit_var[i] for i in trace])
    #print_uninit_var(uninit_var_list)
   
    new_cons = cons_transfer(block_cons[str(state)], uninit_var_list)
    satisfy_succ = []
    for s in succ_states:
        succ = s.copy()
        son_father = son_father_process.get_son_father()
        while son_father.has_key(str(succ)):
            succ = succ.copy()
        succ_ip = succ.se.any_int(succ.ip)
        son_father_process.set_son_father(str(succ), (succ_ip,str(state)))
        block_cons[str(succ)] = new_cons
        for con in new_cons:
            succ.add_constraints(con)
        if not succ.se.symbolic(succ.ip) and succ.satisfiable():
           satisfy_succ.append(succ)
    return satisfy_succ

 
def run_patched_function():
    print '\n########  Run Patched Function  ########'
    global mem_addr, pointer_list, changed_mem_name
    global path_uninit_var, block_cons
    
    mem_addr = get_mem2addr(old_uninit_var_list)
    #print '\nmem_addr:'
    #for m in mem_addr:
    #    print m,mem_addr[m][1]
    args_regs = argument_registers
    args_stacks = {}
    for i in argument_stacks:
        args_stacks[argument_stacks[i][0]] = argument_stacks[i][1]
    all_args = {}
    for i in args_regs:
        all_args[i] = args_regs[i]
    for i in args_stacks:
        all_args[i] = args_stacks[i]
    #print 'all_args:',all_args
    pointer_list = []
    for arg_name in all_args:
        arg_ast = all_args[arg_name]
        pointer_info = check_pointer(arg_ast,arg_ast,mem_addr,init_state1)
        if pointer_info:
            pointer_list.insert(0,(arg_name,arg_ast,pointer_info))
    #print 'pointer_list:',pointer_list
    changed_mem_name = []
   
    path_uninit_var = {} 
    s = heap_patch_core.initialize(proj2, func_addr2, init_state2.copy())
    block_cons = {str(s):old_constraints}
    son_father_process.set_son_father(str(s),(func_addr2,None))
    q = [s]
    while q:
        state = q.pop()
        succ_states = detect_with_new_cons(state)
        for succ in succ_states:
            q.insert(0, succ)
            

if __name__ == "__main__":
    ''' 
    trace = [0x8734C50,0x8734C71,0x8734C80,0x8734CAE,0x8734CB7,0x8734CC0,0x8734CC6,0x8734CD6]
    state, uninit_var, args_regs, args_stacks = get_uninit_var('ffmpeg_g-patch32',0x8734C50,trace)
    state1, uninit_var1, args_regs1, args_stacks1 = get_uninit_var('ffmpeg_g',0x8734C70,[])

    trace = [0x805B030,0x805B047,0x805B04F,0x805B05A,0x805B06F,0x805B078,0x805B081,0x805B099,0x805B3D8,0x805b3e7,0x805B438]
    state, uninit_var, args_regs, args_stacks = get_uninit_var('test-mnote',0x805B030,trace)
    state1, uninit_var1, args_regs1, args_stacks1 = get_uninit_var('test-mnote-patch',0x805B030,[])
    '''

    global binary1, func_addr1, binary2, func_addr2
    global proj1, init_state1, proj2, init_state2
    global sp_addr
    
    ''' 
    binary1 = 'test4.o'
    func_addr1 = 0x4005BD
    binary2 = 'test4-patch.o'
    func_addr2 = 0x4005BD
    
    binary1 = 'test2.o'
    func_addr1 = 0x40057D
    binary2 = 'test2-patch.o'
    func_addr2 = 0x40057D
    '''
    if len(sys.argv) < 5:
        print 'Too few arguments'
        exit()
    binary1 = sys.argv[1]
    func_addr1 = int(sys.argv[2],16)
    binary2 = sys.argv[3]
    func_addr2 = int(sys.argv[4],16)
    
    proj1 = angr.Project(binary1)
    init_state1 = proj1.factory.blank_state(addr=func_addr1)
    init_state1.options.add(simuvex.o.UNDER_CONSTRAINED_SYMEXEC)
    proj2 = angr.Project(binary2)
    init_state2 = proj2.factory.blank_state(addr=func_addr2)
    init_state2.options.add(simuvex.o.UNDER_CONSTRAINED_SYMEXEC)

    sp_addr = init_state1.se.any_int(init_state1.regs.sp)

    
    f = open('detect_result_heap.txt','r')
    lines = f.readlines()
    f.close()
    if not lines:
        print 'No error traces'
        exit()
    items = [eval(l.split(':')[1]) for l in lines]
    traces = []
    for t in items:
        t1 = [eval(i) for i in t]
        if t1 not in traces:
            traces.append(t1)
    #print 'traces:'
    #for i in traces:
    #    print i
    trace = traces[-1] 
    
    #trace = [0x40057D,0x400593,0x4005BA,0x4005DF]
    print 'Error Trace:',[hex(i) for i in trace]

    run_original_function(trace)
    get_args()
    run_patched_function()

