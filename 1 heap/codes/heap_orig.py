from os import urandom
import angr
import claripy
import cle
import archinfo
import simuvex
import sys
import re

class HeapRegion(object):
    def __init__(self, heap_start, heap_length):
        self.heapStart = heap_start
        self.heapEnd = self.heapStart + heap_length
        self.heapLength = heap_length
        self.beRedStart = self.heapStart - red_length
        self.beRedEnd = self.heapStart
        self.afRedStart = self.heapEnd
        self.afRedEnd = self.heapEnd + red_length
        self.isRemoved = False
        '''
        print '------------------------------------------------------------------'
        print "[red_start:{}~~red_end:{}]".format(hex(self.beRedStart),hex(self.beRedEnd))
        print "[heap_start:{}~~heap_end:{}]".format(hex(self.heapStart),hex(self.heapEnd))
        print "[red_start:{}~~red_end:{}]".format(hex(self.afRedStart),hex(self.afRedEnd))
        print '------------------------------------------------------------------'
        '''
    def heap_copy(self):
        copy_region = HeapRegion(self.heapStart, self.heapLength)
        copy_region.isRemoved = self.isRemoved
        return copy_region
    def is_pre_over_flow(self, addr, state):
        if self.isRemoved == False and state.se.satisfiable([addr>self.beRedStart, addr<self.beRedEnd]):
            return True
        else:
            return False
    def is_post_over_flow(self, addr, state):
        if self.isRemoved == False and state.se.satisfiable([addr>self.afRedStart, addr<self.afRedEnd]):
            return True
        else:
            return False
    def is_over_flow(self, addr, state):
        if self.is_pre_over_flow(self, addr, state) or self.is_post_over_flow(self, addr, state):
            return True
        else:
            return False
    def is_use_after_free(self,addr, state):
        if self.isRemoved == True and state.se.satisfiable([addr>=self.heapStart, addr<=self.heapEnd]):
            return True
        else:
            return False

class HeapRegions(object):
    __slots__ = ['regions','simRunAddr']
    def __init__(self,simRunAddr):     
        self.regions = set()
        self.simRunAddr = simRunAddr
    def add(self, heap_region):
        if type(heap_region) is HeapRegion:
            self.regions.add(heap_region)
        else:
            for heRe in heap_region:
                heRe.heap_copy()
                self.regions.add(heRe.heap_copy())
    def remove(self, heap_start,dup):
        for heap in self.regions:
            if heap.heapStart == heap_start:
                if heap.isRemoved == True and dup == True:
                    print 'double free:{}'.format(hex(heap_start))
                    return True
                else:
                    print 'free:{}'.format(hex(heap_start))
                    heap.isRemoved = True
                    return False
    def is_pre_over_flow(self, addr, state):
        for heap in self.regions:
            if heap is not None:
                if heap.is_pre_over_flow(addr,state):
                    #print 'pre overflow:{}'.format(hex(addr))
                    print 'pre overflow'
                    return True
        return False
    def is_post_over_flow(self, addr, state):
        for heap in self.regions:
            if heap is not None:
                if heap.is_post_over_flow(addr,state):
                    #print 'post overflow:{}'.format(hex(addr))
                    print 'post overflow'
                    return True
        return False
    def is_over_flow(self, addr, state):
        if self.is_pre_over_flow(addr,state) or self.is_post_over_flow(addr,state):
            return True
        else:
            return False
    def is_use_after_free(self, addr, state):
        for heap in self.regions:
            if heap is not None:
                if heap.is_use_after_free(addr,state):
                    #print 'use after free:{}'.format(hex(addr))
                    print 'use after free'
                    return True
        return False

class PathHeapRegions(object):
    __slots__ = ['path_regions']
    def __init__(self):
        self.path_regions = set()
    def add(self, paregion):
        foundDup = None
        found = False
        for region in self.path_regions:
            if paregion.simRunAddr == region.simRunAddr:
                foundDup = region
                found = True
                break
        if found == True:
            self.path_regions.remove(foundDup)  
        self.path_regions.add(paregion)

def get_path(state):
    stashes = pg.stashes
    conb = []
    for b in state.se.constraints:
        conb.append(b._hash)
    hash_conb = hash(str(conb))
    for _, pa in stashes.iteritems():
        for paa in pa:
            cona = []
            for a in paa.state.se.constraints:
                cona.append(a._hash)
            hash_cona = hash(str(cona))
            if hash_cona == hash_conb:
                return paa

def get_trace(path_for_trace):
    ta =path_for_trace.trace.__reversed__()
    trace = []
    for t in ta:
        trace.append(t)
    return trace[::-1]

def path_step_pre_analysis(state):
    #print '\npre_path>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>',state.ip
    traceback = getattr(state.inspect,'path')
    paa = get_path(state)
    if paa._run == None:
        return
    found = False
    found_heap_set = None
    for heap_set in path_heap_set.path_regions:
        if paa.previous_run is not None and heap_set.simRunAddr == paa.previous_run.addr:
            found = True
            found_heap_set = heap_set
            break
        elif paa.previous_run is None:
            return
    if found == True:
        newHeapRegion = HeapRegions(paa._run.addr)         
        newHeapRegion.add(found_heap_set.regions)
        #print type(paa._run)
        #print type(paa.previous_run)
        #print type(malloc_region)
        if paa._run.addr == malloc_address and paa.previous_run.addr == malloc_region[0]:
            newHeapRegion.add(malloc_region[1])
        elif paa._run.addr == free_address and paa.previous_run.addr == free_region[0]:
            if newHeapRegion.remove(free_region[1],True):
                f = open('our_name.txt','a')
                f.write('double free:'+str([hex(i) for i in paa.addr_trace] + [hex(paa._run.addr)])+'\n')
                f.close()
        path_heap_set.add(newHeapRegion) 
    #print 'pre_path<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<'

def call_pre_analysis(state):
    #print 'pre_call>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>'
    global malloc_region, free_region
    fun_name = getattr(state.inspect,'simprocedure_name')
    fun_address = getattr(state.inspect, 'simprocedure_addr')
    try:
        func_object = proj._sim_procedures[fun_address].procedure(fun_address,proj.arch)
        arg_reg_sim_value = func_object.cc.arg(state, 0)
    except Exception,e:
        return
    if fun_name == 'malloc':
        # arg_reg_value (byte)
        if state.se.symbolic(arg_reg_sim_value):
            arg_reg_value = state.se.max_int(arg_reg_sim_value)
            if arg_reg_value > state.libc.max_variable_size:
                arg_reg_value = state.libc.max_variable_size
        else:
            arg_reg_value = state.se.any_int(arg_reg_sim_value)
        #print 'pre_malloc:{}'.format(hex(state.libc.heap_location))
        state.libc.heap_location += red_length*2
        heap_start = state.libc.heap_location
        heap_length = arg_reg_value
        paa = get_path(state)
        for heap_set in path_heap_set.path_regions:
            if  paa.previous_run is not None and  heap_set.simRunAddr == paa.previous_run.addr or \
                paa.previous_run is None and heap_set.simRunAddr == func_addr:
                malloc_region = (heap_set.simRunAddr,HeapRegion(heap_start, heap_length))
                break
    elif fun_name == 'free':
        arg_reg_value = state.se.any_int(arg_reg_sim_value)
        paa = get_path(state)
        paa_trace = get_trace(paa)
        for heap_set in path_heap_set.path_regions:
            if paa.previous_run is not None and heap_set.simRunAddr == paa.previous_run.addr or \
                paa.previous_run is None and heap_set.simRunAddr == func_addr:
                free_region = (heap_set.simRunAddr,arg_reg_value)
                break
    #print 'pre_call<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<'

def call_post_analysis(state):
    #print 'post_call>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>'
    fun_name = getattr(state.inspect,'simprocedure_name')
    if fun_name == 'malloc':
        state.libc.heap_location += red_length
    #print 'post_call<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<'
    
def mem_write_pre_analysis(state):
    #print 'memWrite<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<'    
    #write_sim_addr = getattr(state.inspect, 'mem_write_address')
    write_addr = getattr(state.inspect, 'mem_write_address')
    s1 = state.copy()
    paa = get_path(state)
    paa_trace = get_trace(paa)
    if list(state.log.actions):
        block_addr = list(state.log.actions)[0].bbl_addr
    else:
        block_addr = state.se.any_int(state.ip)
    #print 'block_addr:',hex(block_addr)
    for heap_set in path_heap_set.path_regions:
        if paa.previous_run is not None and heap_set.simRunAddr == paa.previous_run.addr or\
           paa.previous_run is None and heap_set.simRunAddr == func_addr:
            if heap_set.is_use_after_free(write_addr,s1):
                print 'use_after_free:',paa_trace
                f = open('detect_result_heap.txt','a')
                f.write('use after free:'+str( [hex(i) for i in paa.addr_trace]+[hex(block_addr)] )+'\n')
                f.close()
            if heap_set.is_over_flow(write_addr,s1):
                print 'over_flow:',paa_trace
                f = open('detect_result_heap.txt','a')
                f.write('over flow:'+str( [hex(i) for i in paa.addr_trace]+[hex(block_addr)] )+'\n')
                f.close()
    #print 'memWrite>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>'    

def mem_read_pre_analysis(state):
    print '\nmemRead<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<',state.ip
    #read_sim_addr = getattr(state.inspect, 'mem_read_address')
    read_addr = getattr(state.inspect, 'mem_read_address')
    #print 'read_addr:',read_addr
    s1 = state.copy()
    #print 'read addr any_int:',hex(s1.se.any_int(read_addr))
    #print 'same?:',s1.se.constraints == state.se.constraints
    paa = get_path(state)
    paa_trace = get_trace(paa)
    if list(state.log.actions):
        block_addr = list(state.log.actions)[0].bbl_addr
    else:
        block_addr = state.se.any_int(state.ip)
    #print 'block_addr:',hex(block_addr)
    for heap_set in path_heap_set.path_regions:
        if paa.previous_run is not None and heap_set.simRunAddr == paa.previous_run.addr or\
           paa.previous_run is None and heap_set.simRunAddr == func_addr:
            if heap_set.is_use_after_free(read_addr,s1):
                print 'use_after_free:',paa_trace
                f = open('detect_result_heap.txt','a')
                f.write('use after free:'+str( [hex(i) for i in paa.addr_trace]+[hex(block_addr)] )+'\n')
                f.close()
            if heap_set.is_over_flow(read_addr,s1):
                print 'over_flow:',paa_trace
                f = open('detect_result_heap.txt','a')
                f.write('over flow:'+str( [hex(i) for i in paa.addr_trace]+[hex(block_addr)] )+'\n')
                f.close()
    #print 'memRead>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>'    

def get_sim_free():
    res = []
    for heap_set in path_heap_set.path_regions:
        for a in heap_set.regions:
            res.append((hex(heap_set.simRunAddr),a.isRemoved,'['+hex(a.heapStart)+'~'+hex(a.heapEnd)+']'))
    return  res

if __name__=='__main__':
    global proj, proj_main_bin
    global path_heap_set,func_addr,red_length
    global malloc_address, free_address, malloc_region, free_region
    path_heap_set = PathHeapRegions()
    red_length = 8
    malloc_address = None
    free_address = None
    malloc_region = None
    free_region = None
    global_write_addrs = set()
    proj = angr.Project(sys.argv[1])
    func_addr = int(sys.argv[2],16)
    proj_main_bin = proj.loader.main_bin
    f = open('detect_result_heap.txt','w')
    f.close()
    entr_state = proj.factory.blank_state(addr=func_addr)
    entr_state.options.add(simuvex.o.UNDER_CONSTRAINED_SYMEXEC)
    entr_state.options.remove(simuvex.o.COW_STATES)
    entr_state.inspect.b('simprocedure', when=simuvex.BP_BEFORE, action=call_pre_analysis)
    entr_state.inspect.b('simprocedure', when=simuvex.BP_AFTER, action=call_post_analysis)
    entr_state.inspect.b('mem_write', when=simuvex.BP_AFTER, action=mem_write_pre_analysis)
    entr_state.inspect.b('mem_read', when=simuvex.BP_AFTER, action=mem_read_pre_analysis)
    entr_state.inspect.b('path_step', when=simuvex.BP_BEFORE, action=path_step_pre_analysis)
    p = proj.factory.path(state=entr_state)
    ''' 
    print '##########################################'
    print proj._sim_procedures
    print '##########################################'
    '''
    for proc in proj._sim_procedures:
        if proj._sim_procedures[proc].name=='malloc':
            malloc_address = proc
        elif proj._sim_procedures[proc].name=='free':
            free_address = proc
    newHeapRegion = HeapRegions(func_addr)
    path_heap_set.add(newHeapRegion) 
    pg = proj.factory.path_group(p)
    pg.explore()
    
    print '\n',pg
    #print get_sim_free()
    if len(pg.deadended) >0:
        print 'deadended:',get_trace(pg.deadended[0])
    if len(pg.errored)>0:
        print 'errored:',get_trace(pg.errored[0])
