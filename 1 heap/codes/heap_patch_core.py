from os import urandom
import angr
import claripy
import cle
import archinfo
import simuvex
import sys
import re
import son_father_process

class HeapRegion(object):
    def __init__(self, heap_start, heap_length):
        self.heapStart = heap_start
        self.heapEnd = self.heapStart + heap_length
        self.heapLength = heap_length
        self.beRedStart = self.heapStart - red_length
        self.beRedEnd = self.heapStart
        self.afRedStart = self.heapEnd
        self.afRedEnd = self.heapEnd + red_length
        self.isRemoved = False
        '''
        print '------------------------------------------------------------------'
        print "[red_start:{}~~red_end:{}]".format(hex(self.beRedStart),hex(self.beRedEnd))
        print "[heap_start:{}~~heap_end:{}]".format(hex(self.heapStart),hex(self.heapEnd))
        print "[red_start:{}~~red_end:{}]".format(hex(self.afRedStart),hex(self.afRedEnd))
        print '------------------------------------------------------------------'
        '''
    def heap_copy(self):
        copy_region = HeapRegion(self.heapStart, self.heapLength)
        copy_region.isRemoved = self.isRemoved
        return copy_region
    def is_pre_over_flow(self, addr, state):
        if self.isRemoved == False and state.se.satisfiable([addr>self.beRedStart, addr<self.beRedEnd]):
            return True
        else:
            return False
    def is_post_over_flow(self, addr, state):
        if self.isRemoved == False and state.se.satisfiable([addr>self.afRedStart, addr<self.afRedEnd]):
            return True
        else:
            return False
    def is_over_flow(self, addr, state):
        if self.is_pre_over_flow(self, addr, state) or self.is_post_over_flow(self, addr, state):
            return True
        else:
            return False
    def is_use_after_free(self,addr, state):
        if self.isRemoved == True and state.se.satisfiable([addr>=self.heapStart, addr<=self.heapEnd]):
            return True
        else:
            return False

class HeapRegions(object):
    __slots__ = ['regions','simRunAddr']
    def __init__(self,simRunAddr):     
        self.regions = set()
        self.simRunAddr = simRunAddr
    def add(self, heap_region):
        if type(heap_region) is HeapRegion:
            self.regions.add(heap_region)
        else:
            for heRe in heap_region:
                heRe.heap_copy()
                self.regions.add(heRe.heap_copy())
    def remove(self, heap_start,dup):
        for heap in self.regions:
            if heap.heapStart == heap_start:
                if heap.isRemoved == True and dup == True:
                    print 'double free:{}'.format(hex(heap_start))
                    return True
                else:
                    print 'free:{}'.format(hex(heap_start))
                    heap.isRemoved = True
                    return False
    def is_pre_over_flow(self, addr, state):
        #print self.regions,hex(addr)
        for heap in self.regions:
            if heap is not None:
                if heap.is_pre_over_flow(addr,state):
                    #print 'pre overflow:{}'.format(hex(addr))
                    return True
        return False
    def is_post_over_flow(self, addr, state):
        for heap in self.regions:
            if heap is not None:
                if heap.is_post_over_flow(addr,state):
                    #print 'post overflow:{}'.format(hex(addr))
                    return True
        return False
    def is_over_flow(self, addr, state):
        if self.is_pre_over_flow(addr,state) or self.is_post_over_flow(addr,state):
            return True
        else:
            return False
    def is_use_after_free(self, addr, state):
        for heap in self.regions:
            if heap is not None:
                if heap.is_use_after_free(addr,state):
                    #print 'use after free:{}'.format(hex(addr))
                    return True
        return False

class PathHeapRegions(object):
    __slots__ = ['path_regions']
    def __init__(self):
        self.path_regions = set()
    def add(self, paregion):
        foundDup = None
        found = False
        for region in self.path_regions:
            if paregion.simRunAddr == region.simRunAddr:
                foundDup = region
                found = True
                break
        if found == True:
            self.path_regions.remove(foundDup)  
        self.path_regions.add(paregion)

# ************ added by pjq ************
def get_trace(state):
    trace = []
    son_father = son_father_process.get_son_father()
    father = str(state)
    while father:
        trace.insert(0, son_father[father][0])
        father = son_father[father][1]
    return trace

def get_last_block_addr(state):
    son_father = son_father_process.get_son_father()
    father = son_father[str(state)][1]
    if father:
        last_block_addr = son_father[father][0]
    else:
        last_block_addr = None
    return last_block_addr

    
def path_step_pre_analysis(state):
    #print '\npre_path>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>'
    traceback = getattr(state.inspect,'path')
    state_ip = state.se.any_int(state.ip)
    last_block_addr = get_last_block_addr(state)
    found = False
    found_heap_set = None
    for heap_set in path_heap_set.path_regions:
        if last_block_addr is not None and heap_set.simRunAddr == last_block_addr:
            found = True
            found_heap_set = heap_set
            break
        elif last_block_addr is None:
            return
    if found == True:
        newHeapRegion = HeapRegions(state_ip)
        newHeapRegion.add(found_heap_set.regions)
        # ************ changed by pjq ************
        # change paa._run.addr with state_ip
        # change paa.previous_run.addr with last_block_addr
        if state_ip == malloc_address and last_block_addr == malloc_region[0]:
            newHeapRegion.add(malloc_region[1])
        elif state_ip == free_address and last_block_addr == free_region[0]:
            newHeapRegion.remove(free_region[1],True)
        path_heap_set.add(newHeapRegion) 
    #print 'pre_path<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<'


def call_pre_analysis(state):
    #print 'pre_call>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>'
    global malloc_region, free_region
    fun_name = getattr(state.inspect,'simprocedure_name')
    fun_address = getattr(state.inspect, 'simprocedure_addr')
    arg_reg_name = simuvex.DefaultCC[proj.arch.name].ARG_REGS[0]
    arg_reg_sim_value = state.regs.get(arg_reg_name)
    if fun_name == 'malloc':
        if state.se.symbolic(arg_reg_sim_value):
            arg_reg_value = state.se.max_int(arg_reg_sim_value)
            #print 'malloc_size:',arg_reg_value
            if arg_reg_value > state.libc.max_variable_size:
                arg_reg_value = state.libc.max_variable_size
        else:
            arg_reg_value = state.se.any_int(arg_reg_sim_value)*8
        #print 'pre_malloc:{}'.format(hex(state.libc.heap_location))
        state.libc.heap_location += red_length*2
        heap_location = state.libc.heap_location
        heap_start = state.libc.heap_location
        heap_length = arg_reg_value
        # ************ changed by pjq ************
        block_state = son_father_process.get_state()
        last_block_addr = get_last_block_addr(block_state)
        for heap_set in path_heap_set.path_regions:
            if  last_block_addr is not None and  heap_set.simRunAddr == last_block_addr or \
                last_block_addr is None and heap_set.simRunAddr == func_addr:
                malloc_region = (heap_set.simRunAddr,HeapRegion(heap_start, heap_length))
                break
    elif fun_name == 'free':
        arg_reg_value = state.se.any_int(arg_reg_sim_value)
        # ************ changed by pjq ************
        block_state = son_father_process.get_state()
        last_block_addr = get_last_block_addr(block_state)
        for heap_set in path_heap_set.path_regions:
            if last_block_addr is not None and heap_set.simRunAddr == last_block_addr or \
                last_block_addr is None and heap_set.simRunAddr == func_addr:
                free_region = (heap_set.simRunAddr,arg_reg_value)
                break
    #print 'pre_call<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<'

def call_post_analysis(state):
    #print 'post_call>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>'
    fun_name = getattr(state.inspect,'simprocedure_name')
    arg_reg_name = simuvex.DefaultCC[proj.arch.name].ARG_REGS[0]
    arg_reg_sim_value = state.regs.get(arg_reg_name)
    if fun_name == 'malloc':
        state.libc.heap_location += red_length
        heap_location = state.libc.heap_location 
    #print 'post_call<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<'

    
def mem_write_pre_analysis(state):
    #print '\nmemWrite<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<'    
    #write_sim_addr = getattr(state.inspect, 'mem_write_address')
    # ************ changed by pjq ************
    write_addr = getattr(state.inspect, 'mem_write_address')
    s1 = state.copy()
    block_state = son_father_process.get_state()
    last_block_addr = get_last_block_addr(block_state)
    paa_trace = get_trace(block_state)
    for heap_set in path_heap_set.path_regions:
        if last_block_addr is not None and heap_set.simRunAddr == last_block_addr or\
           last_block_addr is None and heap_set.simRunAddr == func_addr:
           if heap_set.is_use_after_free(write_addr,s1):
               print 'use_after_free:',paa_trace
           if heap_set.is_over_flow(write_addr,s1):
               print 'over_flow:',paa_trace
    #print 'memWrite>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>'    

def mem_read_pre_analysis(state):
    #print '\nmemRead<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<'    
    #read_sim_addr = getattr(state.inspect, 'mem_read_address')
    #read_addr = state.se.any_int(read_sim_addr)
    # ************ changed by pjq ************
    read_addr = getattr(state.inspect, 'mem_read_address')
    s1 = state.copy()
    block_state = son_father_process.get_state()
    last_block_addr = get_last_block_addr(block_state)
    paa_trace = get_trace(block_state)
    for heap_set in path_heap_set.path_regions:
        if last_block_addr is not None and heap_set.simRunAddr == last_block_addr or\
           last_block_addr is None and heap_set.simRunAddr == func_addr:
           if heap_set.is_use_after_free(read_addr,s1):
               print 'use_after_free:',paa_trace
           if heap_set.is_over_flow(read_addr,s1):
               print 'over_flow:',paa_trace
    #print 'memRead>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>'    

    
def initialize(proj0, func_addr0, entr_state0):
    global proj, func_addr, entr_state, proj_main_bin
    global path_heap_set,red_length
    global malloc_address, free_address, malloc_region, free_region
    proj = proj0
    func_addr = func_addr0
    entr_state = entr_state0
    
    proj_main_bin = proj.loader.main_bin
    path_heap_set = PathHeapRegions()
    red_length = 8
    heap_location = entr_state.libc.heap_location
    call_post_set = set()
    malloc_address = None
    free_address = None
    malloc_region = None
    free_region = None
    #entr_state.options.remove(simuvex.o.COW_STATES)
    entr_state.inspect.b('simprocedure', when=simuvex.BP_BEFORE, action=call_pre_analysis)
    entr_state.inspect.b('simprocedure', when=simuvex.BP_AFTER, action=call_post_analysis)
    entr_state.inspect.b('mem_write', when=simuvex.BP_AFTER, action=mem_write_pre_analysis)
    entr_state.inspect.b('mem_read', when=simuvex.BP_AFTER, action=mem_read_pre_analysis)
    entr_state.inspect.b('path_step', when=simuvex.BP_BEFORE, action=path_step_pre_analysis)
    #print '##########################################'
    #print proj._sim_procedures
    #print '##########################################'
    for proc in proj._sim_procedures:
        if proj._sim_procedures[proc].name=='malloc':
            malloc_address = proc
        elif proj._sim_procedures[proc].name=='free':
            free_address = proc
    newHeapRegion = HeapRegions(func_addr)
    path_heap_set.add(newHeapRegion) 
    
    return entr_state
    
    
if __name__=='__main__':
    proj = angr.Project(sys.argv[1])
    func_addr = int(sys.argv[2],16)
    entr_state = proj.factory.blank_state(addr=func_addr)
    entr_state.options.add(simuvex.o.UNDER_CONSTRAINED_SYMEXEC)
    addr_trace = [4195773, 4195520, 67108896, 4195797, 4195807, 4195456, 67108912, 4195819, 4195825, 4195456, 67108912]
    #addr_trace = [4195773, 4195520, 67108896, 4195797, 4195839, 4195850]
    initialize(proj, func_addr, entr_state)
