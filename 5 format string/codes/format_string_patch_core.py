from os import urandom
import angr
import claripy
import cle
import archinfo
import simuvex
import sys
import re
import itertools
import son_father_process
var_counter = itertools.count()

def if_comefrom_input(data):
    pattern = re.compile(r'taint')
    match = pattern.search(str(data.args[0]))
    print data
    if match:
        print 'format string danger!!!'
        return True
    else:
        return False

# ************ added by pjq ************
def get_trace(state):
    trace = []
    son_father = son_father_process.get_son_father()
    father = str(state)
    while father:
        trace.insert(0, son_father[father][0])
        father = son_father[father][1]
    return trace


def reg_read_pre_analysis(state):
    global accessed_registers
    reg_expr = getattr(state.inspect, 'reg_read_expr')
    reg_offset = getattr(state.inspect, 'reg_read_offset')
    reg_name = proj.arch.register_names[reg_offset]
    arg_registers = simuvex.DefaultCC[proj.arch.name].ARG_REGS
    if reg_name in arg_registers and reg_name not in accessed_registers:
        accessed_registers.add(reg_name)
        try:
            old_value = state.registers.load(reg_name)
            old_name = old_value.args[0]
            new_reg_value = claripy.BVS(old_name+'_taint_%d'%(var_counter.next()),state.arch.bits,explicit_name=True)
            state.registers.store(reg_name,new_reg_value)
        except Exception,e:
            print e

def reg_write_pre_analysis(state):
    global accessed_registers
    arg_registers = simuvex.DefaultCC[proj.arch.name].ARG_REGS
    reg_offset = getattr(state.inspect, 'reg_write_offset')
    if reg_name in arg_registers and reg_name not in accessed_registers:
        accessed_registers.add(reg_name)    

def mem_read_pre_analysis(state):
    mem_read_sim_address = getattr(state.inspect,'mem_read_address')
    mem_read_sim_length = getattr(state.inspect, 'mem_read_length')
    mem_read_sim_expr = getattr(state.inspect, 'mem_read_expr')
    bp_addr = state.se.any_int(state.regs.bp)
    mem_read_address = state.se.any_int(mem_read_sim_address)
    mem_read_length = state.se.any_int(mem_read_sim_length)
    #print mem_read_sim_address, mem_read_address
    if mem_read_address >= bp_addr and mem_read_address < bp_addr+0x100:
        if mem_read_length > 32:
            mem_read_length = 32
        old_value = state.memory.load(mem_read_sim_address)
        old_name = old_value.args[0]
        for i in range(mem_read_length):
            try:
                data = claripy.BVS(old_name+'_taint_%d'%(var_counter.next()),8,explicit_name=True)
                state.memory.store(mem_read_sim_address+i,data)
            except Exception,e:
                print e

def call_pre_analysis(state):
    #print 'pre_call>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>'
    arch_length = simuvex.DefaultCC[proj.arch.name].ARCH.bits/8
    #pre_ebp = state.memory.load(,arch_length)
    fun_name = getattr(state.inspect,'simprocedure_name')
    fun_address = getattr(state.inspect, 'simprocedure_addr')
    try:
        func_object = proj._sim_procedures[fun_address].procedure(fun_address,proj.arch)
    except Exception,e:
        return
    block_state = son_father_process.get_state()
    paa_trace = get_trace(block_state)
    if fun_name == 'printf':
        arg0 = func_object.cc.arg(state, 0)
        if if_comefrom_input(arg0):
            print [hex(i) for i in paa_trace]
    elif fun_name == 'sprintf': 
        arg1 = func_object.cc.arg(state, 1)
        if if_comefrom_input(arg1):
            print [hex(i) for i in paa_trace]
    elif fun_name == 'fprintf': 
        arg1 = func_object.cc.arg(state, 1)
        if if_comefrom_input(arg1):
            print [hex(i) for i in paa_trace]

    #print 'pre_call<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<'

def call_post_analysis(state):
    fun_name = getattr(state.inspect,'simprocedure_name')
    fun_address = getattr(state.inspect, 'simprocedure_addr')
    try:
        func_object = proj._sim_procedures[fun_address].procedure(fun_address,proj.arch)
    except Exception,e:
        return 
    if fun_name == 'fread':
        arg0_reg = func_object.cc.arg(state,0)
        arg1_reg = func_object.cc.arg(state,1)
        arg2_reg = func_object.cc.arg(state,2)
        size = state.se.max_int(arg1_reg) * state.se.max_int(arg2_reg)
        for i in range(size):
            state.memory.make_symbolic('taint', arg0_reg+i, size)
            sim_data = state.memory.load(arg0_reg+i,1)
    elif fun_name == 'read':
        arg0_reg = func_object.cc.arg(state,0)
        arg1_reg = func_object.cc.arg(state,1)
        arg2_reg = func_object.cc.arg(state,2)
        size = state.se.max_int(arg2_reg)
        for i in range(size):
            state.memory.make_symbolic('taint', arg1_reg+i, size)
            sim_data = state.memory.load(arg0_reg+i,1)
    elif fun_name == 'recv':
        arg0_reg = func_object.cc.arg(state,0)
        arg1_reg = func_object.cc.arg(state,1)
        arg2_reg = func_object.cc.arg(state,2)
        size = state.se.max_int(arg2_reg)
        for i in range(size):
            state.memory.make_symbolic('taint', arg1_reg+i, size)
            sim_data = state.memory.load(arg0_reg+i,1)
    elif fun_name == 'recvfrom':
        arg0_reg = func_object.cc.arg(state,0)
        arg1_reg = func_object.cc.arg(state,1)
        arg2_reg = func_object.cc.arg(state,2)
        size = state.se.max_int(arg2_reg)
        for i in range(size):
            state.memory.make_symbolic('taint', arg1_reg+i, size)
            sim_data = state.memory.load(arg0_reg+i,1)


def initialize(proj0, func_addr0, entr_state0):
    global proj, func_addr, entr_state, proj_main_bin
    global args_set, accessed_registers
    proj = proj0
    func_addr = func_addr0
    entr_state = entr_state0
    proj_main_bin = proj.loader.main_bin 
    args_set = set()    
    accessed_registers = set()
    entr_state.options.remove(simuvex.o.COW_STATES)
    entr_state.inspect.b('simprocedure', when=simuvex.BP_BEFORE, action=call_pre_analysis)
    entr_state.inspect.b('simprocedure', when=simuvex.BP_AFTER, action=call_post_analysis)
    entr_state.inspect.b('reg_read', when=simuvex.BP_BEFORE, action=reg_read_pre_analysis)
    entr_state.inspect.b('mem_read', when=simuvex.BP_BEFORE, action=mem_read_pre_analysis)
    return entr_state
    

if __name__=='__main__':
    proj = angr.Project(sys.argv[1])
    func_addr = int(sys.argv[2],16)
    entr_state = proj.factory.blank_state(addr=func_addr)
    entr_state.options.add(simuvex.o.UNDER_CONSTRAINED_SYMEXEC)
    entr_state = initialize(proj, func_addr, entr_state)
    p = proj.factory.path(state=entr_state)
    pg = proj.factory.path_group(p)
    pg.explore()
