import angr
import claripy
import cle
import archinfo
import simuvex
import sys

def get_args(binary,func_addr):
    global args_set
    b = angr.Project(binary)
    init_state = b.factory.blank_state(addr=func_addr)
    init_state.options.add(simuvex.o.UNDER_CONSTRAINED_SYMEXEC)
    q = [init_state]
    block_exectimes = {}

    argument_registers = {}
    argument_stacks = {}
    argument_register_size = {}
    argument_stack_size = {}
    
    sp_addr = init_state.se.any_int(init_state.regs.sp)
    new_sp_addr = sp_addr - b.arch.stack_change
    accessed_registers = set()
    accessed_registers.add(b.arch.registers['bp'][0])
    accessed_registers.add(b.arch.registers['sp'][0])

    while len(q) > 0:
        state = q.pop()
        curr_ip = state.se.any_int(state.ip)
        #print 'block addr:',hex(curr_ip)
        
        # limit execution times of each block
        if block_exectimes.has_key(curr_ip):
            t = block_exectimes[curr_ip]+1
            if t > 10:
                continue
            else:
                block_exectimes[curr_ip] = t
        else:
            block_exectimes[curr_ip] = 1
        
        p = b.factory.path(state) 
        p.step()
        if not p.next_run:
            continue
        
        succ_states = p.next_run.successors
        # there are two situations that need special treatment:
        #   a. fail to reach next block: the last block of func, call symbolic_addr ...
        #   b. there is no next block: exit(0) ...
        if not succ_states:
            succ_states = p.next_run.unconstrained_successors 
        
        # calculate argument of function
        if succ_states:
            succ = succ_states[0]
            actions = list(succ.log.actions)
            for i in xrange(len(actions)):
                a = actions[i]
                if a.type == 'mem' and a.action == 'read':
                    try:
                        addr = succ.se.exactly_int(a.addr.ast, default=0)
                    except claripy.ClaripyError:
                        continue
                    stack_boundary = 0xc0 << (b.arch.bits-8)
                    if addr >= new_sp_addr and addr < stack_boundary:
                        offset = addr - new_sp_addr
                        if offset not in argument_stacks:
                            argument_stacks[offset] =  addr
                elif a.type == "reg":
                    offset = a.offset
                    if a.action == "read" and offset not in accessed_registers:
                        #reg_varname = 'reg_%x' % offset
                        #argument_registers[reg_varname] = a.data.ast 
                        reg_ast = a.data.ast
                        reg_varname = list(reg_ast.variables)[0]
                        argument_registers[reg_varname] = reg_ast    
                        # calculate size of the read reg
                        j = i+1
                        while j<len(actions):
                            a1 = actions[j]
                            try: 
                                if a1.action=='write' and a1.type=='mem':
                                    tmp = a1.data.ast
                                    if list(tmp.variables) and list(tmp.variables)[0] == reg_varname:
                                        argument_register_size[reg_varname] = tmp.length
                                        break
                            except:
                                pass
                            j = j+1
                        
                    elif a.action == "write":
                        accessed_registers.add(offset)

        # add successors to the queue to analyze
        for succ in succ_states:
            if not succ.se.symbolic(succ.ip):
                #print 'succ.ip:',succ.ip
                q.insert(0, succ)


    Arch_Arg_Regs = simuvex.DefaultCC[b.arch.name].ARG_REGS + simuvex.DefaultCC[b.arch.name].FP_ARG_REGS 
    regs = {}
    for i in Arch_Arg_Regs:
        regs[b.arch.registers[i][0]] = i
    argument_regprint = []
    arch_length = simuvex.DefaultCC[proj.arch.name].ARCH.bits/8
    for i in argument_registers:
        j = int('0x'+i.split('_')[1],16)
        arg_value = init_state.se.any_int(init_state.regs.get(regs[j]))
        args_set.add(arg_value)
    for i in argument_stacks:
        arg_value = init_state.se.any_int(init_state.stack_read(argument_stacks[i],arch_length)) 
        args_set.add(arg_value)
class HeapRegion(object):
    def __init__(self, heap_start, heap_length):
        self.heapStart = heap_start
        self.heapEnd = self.heapStart + heap_length
        self.heapLength = heap_length
        self.isRemoved = False
        '''
        print '------------------------------------------------------------------'
        print "[red_start:{}~~red_end:{}]".format(hex(self.beRedStart),hex(self.beRedEnd))
        print "[heap_start:{}~~heap_end:{}]".format(hex(self.heapStart),hex(self.heapEnd))
        print "[red_start:{}~~red_end:{}]".format(hex(self.afRedStart),hex(self.afRedEnd))
        print '------------------------------------------------------------------'
        '''
    def heap_copy(self):
        copy_region = HeapRegion(self.heapStart, self.heapLength)
        copy_region.isRemoved = self.isRemoved
        return copy_region

class HeapRegions(object):
    __slots__ = ['regions','simRunAddr']
    def __init__(self,simRunAddr):     
        self.regions = set()
        self.simRunAddr = simRunAddr
    def add(self, heap_region):
        if type(heap_region) is HeapRegion:
            self.regions.add(heap_region)
        else:
            for heRe in heap_region:
                heRe.heap_copy()
                self.regions.add(heRe.heap_copy())
    def remove(self, heap_start):
        for heap in self.regions:
            if heap.heapStart == heap_start:
                    heap.isRemoved = True
class PathHeapRegions(object):
    __slots__ = ['path_regions']
    def __init__(self):
        self.path_regions = set()
    def add(self, paregion):
        foundDup = None
        found = False
        for region in self.path_regions:
            if paregion.simRunAddr == region.simRunAddr:
                foundDup = region
                found = True
                break
        if found == True:
            self.path_regions.remove(foundDup)  
        self.path_regions.add(paregion)


def path_step_pre_analysis(state):
    #print 'pre_path>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>'
    paa = get_path(state)
    if paa._run == None:
        return
    found = False
    found_heap_set = None
    for heap_set in path_heap_set.path_regions:
        if paa.previous_run is not None and heap_set.simRunAddr == paa.previous_run.addr:
            found = True
            found_heap_set = heap_set
            break
        elif paa.previous_run is None:
            return
    if found == True:
        newHeapRegion = HeapRegions(paa._run.addr)         
        newHeapRegion.add(found_heap_set.regions)
        if paa._run.addr == malloc_address and paa.previous_run.addr == malloc_region[0]:
            newHeapRegion.add(malloc_region[1])
        elif paa._run.addr == free_address and paa.previous_run.addr == free_region[0]:
            newHeapRegion.remove(free_region[1])        
        path_heap_set.add(newHeapRegion) 
    #print 'pre_path<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<'
def get_path(state):
    stashes = pg.stashes
    conb = []
    for b in state.se.constraints:
        conb.append(b._hash)
    hash_conb = hash(str(conb))
    for _, pa in stashes.iteritems():
        for paa in pa:
            cona = []
            for a in paa.state.se.constraints:
                cona.append(a._hash)
            hash_cona = hash(str(cona))
            if hash_cona == hash_conb:
                return paa
def get_trace(path_for_trace):
    ta =path_for_trace.trace.__reversed__()
    trace = []
    for t in ta:
        trace.append(t)
    return trace[::-1]

def get_sim_free():
    res = []
    for heap_set in path_heap_set.path_regions:
        for a in heap_set.regions:
            res.append((hex(heap_set.simRunAddr),a.isRemoved,'['+hex(a.heapStart)+'~'+hex(a.heapEnd)+']'))
    return  res
 
def call_pre_analysis(state):
    #print 'pre_call<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<'
    global malloc_region, free_region
    fun_name = getattr(state.inspect,'simprocedure_name')
    fun_address = getattr(state.inspect, 'simprocedure_addr')
    try:
        func_object = proj._sim_procedures[fun_address].procedure(fun_address,proj.arch)
    except Exception,e:
        return
    arg_reg_sim_value = func_object.cc.arg(state, 0)
    if fun_name == 'malloc':
        if state.se.symbolic(arg_reg_sim_value):
            arg_reg_value = state.se.max_int(arg_reg_sim_value)
            print 'malloc_size:',arg_reg_value
            if arg_reg_value > state.libc.max_variable_size:
                arg_reg_value = state.libc.max_variable_size
        else:
            arg_reg_value = state.se.any_int(arg_reg_sim_value)*8
        #print 'pre_malloc:{}'.format(hex(state.libc.heap_location))
        heap_start = state.libc.heap_location
        heap_length = arg_reg_value
        paa = get_path(state)
        for heap_set in path_heap_set.path_regions:
            if  paa.previous_run is not None and  heap_set.simRunAddr == paa.previous_run.addr or \
                paa.previous_run is None and heap_set.simRunAddr == func_addr:
                malloc_region = (heap_set.simRunAddr,HeapRegion(heap_start, heap_length))
                break
    elif fun_name == 'free':
        arg_reg_value = state.se.any_int(arg_reg_sim_value)
        paa = get_path(state)
        paa_trace = get_trace(paa)
        for heap_set in path_heap_set.path_regions:
            if paa.previous_run is not None and heap_set.simRunAddr == paa.previous_run.addr or \
                paa.previous_run is None and heap_set.simRunAddr == func_addr:
                free_region = (heap_set.simRunAddr,arg_reg_value)
                break
    #print 'pre_call>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>'
def mem_write_pre_analysis(state):
    #print 'memWrite<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<'    
    write_sim_addr = getattr(state.inspect, 'mem_write_address')
    write_sim_expr = getattr(state.inspect, 'mem_write_expr')
    paa = get_path(state)
    paa_trace = get_trace(paa)
    for heap_set in path_heap_set.path_regions:
        if paa.previous_run is not None and heap_set.simRunAddr == paa.previous_run.addr or\
           paa.previous_run is None and heap_set.simRunAddr == func_addr:
            write_addr = state.se.any_int(write_sim_addr)
            write_expr = state.se.any_int(write_sim_expr)
            for he in heap_set.regions:
                if he.heapStart == write_expr:
                    #wait to repaire
                    for arg in args_set:
                        if arg <= write_addr and write_addr <= arg + write_range:
                            #print 'argument:',hex(write_addr)
                            heap_set.remove(write_expr)
                    ################
                    section = proj_main_bin.find_section_containing(write_addr)
                   
                    if section != None:
                        if section.name == '.bss' or section.name == '.data':
                            #print 'global_addr:',write_expr
                            heap_set.remove(write_expr)
                      
   #print 'memWrite>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>'    
def exit_pre_analysis(state):
    global test_fun_ret_addr
    exit_sim_target = getattr(state.inspect, 'exit_target')    
    exit_jumpkind = getattr(state.inspect, 'exit_jumpkind')
    paa = get_path(state)
    paa_trace = get_trace(paa)
    if exit_jumpkind == 'Ijk_Ret' and exit_sim_target != None:
        exit_target = state.se.min_int(exit_sim_target)
        if exit_target == test_fun_ret_addr:
            print 'exit_target:',exit_target
            ret_reg_name = simuvex.DefaultCC[proj.arch.name].RETURN_VAL    
            ret_reg_sim_val = ret_reg_name.get_value(state)
            ret_reg_val = state.se.any_int(ret_reg_sim_val)
            for heap_set in path_heap_set.path_regions:
                if paa.previous_run is not None and heap_set.simRunAddr == paa.previous_run.addr or\
                    paa.previous_run is None and heap_set.simRunAddr == func_addr:
                    for he in heap_set.regions:
                        if he.heapStart == ret_reg_val:
                            print 'ret_reg_val:',ret_reg_val
                            heap_set.remove(ret_reg_val)
                    #memory leak check
                    for he in heap_set.regions:
                        if he.isRemoved == False:
                            print 'memory leak!!!!!!!!!!!!!!' 
                            f = open('detect_result_memory_leak.txt','a')
                            if list(state.log.actions):
                                block_addr = list(state.log.actions)[0].bbl_addr
                            else:
                                block_addr = state.se.any_int(state.ip)
                            f.write('memory leak:'+str([hex(i) for i in paa.addr_trace]+[hex(block_addr)])+'\n')
                            f.close()

def set_return_addr(state): 
    global test_fun_ret_addr
    test_fun_ret = simuvex.DefaultCC[proj.arch.name].RETURN_ADDR
    test_fun_ret.set_value(state, test_fun_ret_addr)

if __name__=='__main__':
    global proj, proj_main_bin
    global path_heap_set,func_addr,red_length
    global malloc_address, free_address, malloc_region, free_region
    path_heap_set = PathHeapRegions()
    malloc_address = None
    free_address = None
    malloc_region = None
    free_region = None
    global_write_addrs = set()
 
    global root_set, heap_set, test_fun_ret_addr, arg_addrs
    global args_set,write_range
   
    root_set = set()
    heap_set = set()
    args_set = set()
    global_write_addrs = set()
    write_range = 0xf
    test_fun_ret_addr =0xffe
    proj = angr.Project(sys.argv[1])
    get_args(sys.argv[1], int(sys.argv[2],16))
    proj_main_bin = proj.loader.main_bin     
    func_addr = int(sys.argv[2],16)
    f = open('detect_result_memory_leak.txt','w')
    f.close()
    entr_state = proj.factory.blank_state(addr=func_addr)
    entr_state.options.add(simuvex.o.UNDER_CONSTRAINED_SYMEXEC)
    entr_state.options.remove(simuvex.o.COW_STATES)
    for proc in proj._sim_procedures:
        if proj._sim_procedures[proc].name=='malloc':
            malloc_address = proc
        elif proj._sim_procedures[proc].name=='free':
            free_address = proc
    set_return_addr(entr_state)
    
    entr_state.inspect.b('simprocedure', when=simuvex.BP_BEFORE, action=call_pre_analysis)
    entr_state.inspect.b('mem_write', when=simuvex.BP_BEFORE, action=mem_write_pre_analysis)
    entr_state.inspect.b('path_step', when=simuvex.BP_BEFORE, action=path_step_pre_analysis)
    entr_state.inspect.b('exit', when=simuvex.BP_BEFORE, action=exit_pre_analysis) 
    
    #entr_state.inspect.b('irsb', when=simuvex.BP_BEFORE, action=irsb_pre_analysis)
    
    newHeapRegion = HeapRegions(func_addr)
    path_heap_set.add(newHeapRegion) 
    p = proj.factory.path(state=entr_state)
    pg = proj.factory.path_group(p)
    pg.explore()
    print pg
    print pg.errored
    print 'heap_region:',get_sim_free()
    if len(pg.deadended) >0:
        print 'deadended:',get_trace(pg.deadended[0])
    if len(pg.errored) >0:
        print 'errored:',get_trace(pg.errored[0])  
   
