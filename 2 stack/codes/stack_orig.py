import angr
import claripy
import cle
import archinfo
import simuvex
import sys

func_addr = None

def get_path(state):
    stashes = pg.stashes
    conb = []
    for b in state.se.constraints:
        conb.append(b._hash)
    hash_conb = hash(str(conb))
    for _, pa in stashes.iteritems():
        for paa in pa:
            cona = []
            for a in paa.state.se.constraints:
                cona.append(a._hash)
            hash_cona = hash(str(cona))
            if hash_cona == hash_conb:
                return paa

def mem_write_pre_analysis(state):
    #print '\nstate:',state.ip
    paa = get_path(state)
    if list(state.log.actions):
        block_addr = list(state.log.actions)[0].bbl_addr
    else:
        block_addr = state.se.any_int(state.ip)
    write_sim_addr = getattr(state.inspect, 'mem_write_address')
    write_sim_length = getattr(state.inspect, 'mem_write_length')
    write_sim_expr = getattr(state.inspect, 'mem_write_expr')
    if state.se.satisfiable():
        #write_addr = state.se.any_int(write_sim_addr)
        write_addr = write_sim_addr
        write_length = state.se.any_int(write_sim_expr.length)/8
        statement = getattr(state.inspect, 'statement')
        instruction = getattr(state.inspect, 'instruction')
        address = getattr(state.inspect, 'address') 
        function_name =getattr(state.inspect, 'function_name')
        state1 = state.copy()
        #if  write_addr < stack_candy_addr and stack_candy_addr < write_addr + write_length \
        #or write_addr >= stack_candy_addr and write_addr + write_length <= stack_candy_addr +0x1000:    
        if state1.se.satisfiable([write_addr < stack_candy_addr, stack_candy_addr < write_addr + write_length]) \
        or state1.se.satisfiable([write_addr >= stack_candy_addr, write_addr + write_length <= stack_candy_addr +0x1000]):
            print '-----------------------stack overflow-----------------------'
            print 'write_addr:',write_addr
            print 'write_length:%x'%write_length 
            print 'heap_location:%x'%state.libc.heap_location     
            print 'function_name:',function_name
            print 'mem_write_analysis stack_candy_addr:%x'%stack_candy_addr
            print '------------------------------------------------------------' 
            f = open('detect_result_stack.txt','a')
            f.write('stack write overflow:'+str( [hex(i) for i in paa.addr_trace]+[hex(block_addr)] )+'\n')
            f.close()

def exit_pre_analysis(state):
    global stack_candy_addr
    exit_sim_target = getattr(state.inspect, 'exit_target')
    exit_jumpkind = getattr(state.inspect, 'exit_jumpkind')
    if exit_jumpkind == 'Ijk_Call':
        stack_candy_sim_addr = state.regs.sp
        stack_candy_addr = state.se.any_int(stack_candy_sim_addr)
        #print 'Ijk_Call stack_candy_addr:%x'%stack_candy_addr
    elif exit_jumpkind == 'Ijk_Ret':
        arch_length = simuvex.DefaultCC[proj.arch.name].ARCH.bits/8
        sim_bp = state.regs.bp
        bpp = state.se.any_int(sim_bp)
        stack_candy_sim_addr = state.memory.load(bpp,arch_length)
        stack_candy_addr = state.se.any_int(stack_candy_sim_addr)
        #print 'Ijk_Ret stack_candy_addr:%x'%stack_candy_addr


if __name__=='__main__':
    global proj, proj_main_bin
    global stack_candy_addr
   
    proj = angr.Project(sys.argv[1])
    func_addr = int(sys.argv[2],16)
    proj_main_bin = proj.loader.main_bin     
    f = open('detect_result_stack.txt','w')
    f.close()
    entr_state = proj.factory.blank_state(addr=func_addr)
    entr_state.options.add(simuvex.o.UNDER_CONSTRAINED_SYMEXEC)
    #entr_state.options.remove(simuvex.o.COW_STATES)
    stack_candy_sim_addr = entr_state.regs.sp
    stack_candy_addr = entr_state.se.any_int(stack_candy_sim_addr)    
    #print 'stack_candy_addr:%x'%stack_candy_addr
    entr_state.inspect.b('mem_write', when=simuvex.BP_BEFORE, action=mem_write_pre_analysis)
    entr_state.inspect.b('exit', when=simuvex.BP_BEFORE, action=exit_pre_analysis)
    p = proj.factory.path(state=entr_state)
    pg = proj.factory.path_group(p)
    pg.explore()
