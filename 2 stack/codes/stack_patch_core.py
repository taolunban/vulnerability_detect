import angr
import claripy
import cle
import archinfo
import simuvex
import sys
import son_father_process

func_addr = None

# ************ added by pjq ************
def get_trace(state):
    trace = []
    son_father = son_father_process.get_son_father()
    father = str(state)
    while father:
        trace.insert(0, son_father[father][0])
        father = son_father[father][1]
    return trace


def mem_write_pre_analysis(state):
    #print '\nstate:',state.ip
    write_sim_addr = getattr(state.inspect, 'mem_write_address')
    write_sim_length = getattr(state.inspect, 'mem_write_length')
    write_sim_expr = getattr(state.inspect, 'mem_write_expr')
    if state.se.satisfiable():
        #write_addr = state.se.any_int(write_sim_addr)
        write_addr = write_sim_addr
        write_length = state.se.any_int(write_sim_expr.length)/8
        statement = getattr(state.inspect, 'statement')
        instruction = getattr(state.inspect, 'instruction')
        address = getattr(state.inspect, 'address') 
        function_name =getattr(state.inspect, 'function_name')
        state1 = state.copy()
        #if  write_addr < stack_candy_addr and stack_candy_addr < write_addr + write_length \
        #or write_addr >= stack_candy_addr and write_addr + write_length <= stack_candy_addr +0x1000:    
        if state1.se.satisfiable([write_addr < stack_candy_addr, stack_candy_addr < write_addr + write_length]) \
        or state1.se.satisfiable([write_addr >= stack_candy_addr, write_addr + write_length <= stack_candy_addr +0x1000]):
            print '-----------------------stack overflow-----------------------'
            print 'write_addr:',write_addr
            print 'write_length:%x'%write_length 
            print 'heap_location:%x'%state.libc.heap_location     
            print 'function_name:',function_name
            print 'mem_write_analysis stack_candy_addr:%x'%stack_candy_addr
            block_state = son_father_process.get_state()
            print 'stack overflow trace:',get_trace(block_state)
            print '------------------------------------------------------------' 

def exit_pre_analysis(state):
    global stack_candy_addr
    exit_sim_target = getattr(state.inspect, 'exit_target')
    exit_jumpkind = getattr(state.inspect, 'exit_jumpkind')
    if exit_jumpkind == 'Ijk_Call':
        stack_candy_sim_addr = state.regs.sp
        stack_candy_addr = state.se.any_int(stack_candy_sim_addr)
        #print 'Ijk_Call stack_candy_addr:%x'%stack_candy_addr
    elif exit_jumpkind == 'Ijk_Ret':
        arch_length = simuvex.DefaultCC[proj.arch.name].ARCH.bits/8
        sim_bp = state.regs.bp
        bpp = state.se.any_int(sim_bp)
        stack_candy_sim_addr = state.memory.load(bpp,arch_length)
        stack_candy_addr = state.se.any_int(stack_candy_sim_addr)
        #print 'Ijk_Ret stack_candy_addr:%x'%stack_candy_addr


def initialize(proj0, func_addr0, entr_state0):
    global proj, func_addr, entr_state
    global stack_candy_addr
    proj = proj0
    func_addr = func_addr0
    entr_state = entr_state0
   
    stack_candy_sim_addr = entr_state.regs.sp
    stack_candy_addr = entr_state.se.any_int(stack_candy_sim_addr)    
    #print 'stack_candy_addr:%x'%stack_candy_addr
    entr_state.inspect.b('mem_write', when=simuvex.BP_BEFORE, action=mem_write_pre_analysis)
    entr_state.inspect.b('exit', when=simuvex.BP_BEFORE, action=exit_pre_analysis)
    return entr_state


if __name__=='__main__':
    proj = angr.Project(sys.argv[1])
    func_addr = int(sys.argv[2],16)
    entr_state = proj.factory.blank_state(addr=func_addr)
    entr_state.options.add(simuvex.o.UNDER_CONSTRAINED_SYMEXEC)
    entr_state = initialize(proj, func_addr, entr_state)
    p = proj.factory.path(state=entr_state)
    pg = proj.factory.path_group(p)
    pg.explore()
